package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"sort"
	"strings"
	"time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

func ensureDirs(userID int64) string {
	path := fmt.Sprintf("%s/%d", dataDir, userID)
	os.MkdirAll(path, 0755)
	return path
}

func getBotToken() string {
	if data, err := os.ReadFile("/run/secrets/telegram_bot_token"); err == nil {
		token := strings.TrimSpace(string(data))
		if token != "" {
			log.Println("‚úÖ –¢–æ–∫–µ–Ω –ø–æ–ª—É—á–µ–Ω –∏–∑ Docker Secret (/run/secrets/telegram_bot_token)")
			return token
		}
	}
	token := strings.TrimSpace(os.Getenv("TELEGRAM_BOT_TOKEN"))
	if token != "" {
		log.Println("‚úÖ –¢–æ–∫–µ–Ω –ø–æ–ª—É—á–µ–Ω –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è (TELEGRAM_BOT_TOKEN)")
		return token
	}
	log.Fatal("‚ùå –¢–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω: –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏ Docker Secret, –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è")
	return ""
}

func countryToFlag(isoCode string) string {
	isoCode = strings.ToUpper(isoCode)
	if len(isoCode) != 2 {
		return ""
	}
	return string(rune(0x1F1E6+int(isoCode[0]-'A'))) + string(rune(0x1F1E6+int(isoCode[1]-'A')))
}

func parseDate(dateStr string) (time.Time, error) {
	return time.Parse("02.01.2006", dateStr)
}

func formatDate(d time.Time) string {
	return d.Format("02.01.2006")
}

func backupSession(s *Session) {
	b, _ := json.MarshalIndent(s.Data, "", "  ")
	_ = os.WriteFile(fmt.Sprintf("%s/backup.json", s.HistoryDir), b, 0644)
	s.Backup = s.Data
}

func saveSession(s *Session) {
	b, _ := json.MarshalIndent(s, "", "  ")
	_ = os.WriteFile(fmt.Sprintf("%s/session.json", s.HistoryDir), b, 0644)
	t := time.Now().Format("2006-01-02_15-04-05")
	_ = os.WriteFile(fmt.Sprintf("%s/report_%s.txt", s.HistoryDir, t), []byte(buildReport(s.Data)), 0644)
}

func loadUserData(s *Session) {
	path := fmt.Sprintf("%s/session.json", s.HistoryDir)
	b, err := os.ReadFile(path)

	if err == nil {
		var restored Session
		if err := json.Unmarshal(b, &restored); err == nil {
			*s = restored
		}
	}
}

func buildReport(data Data) string {
	calcDate, _ := parseDate(data.Current)
	oneYearAgo := calcDate.AddDate(-1, 0, 0).AddDate(0, 0, 1)
	countryDays := make(map[string]int)
	var previousOutDate time.Time

	for i, period := range data.Periods {
		var inDate, outDate time.Time
		if period.Out != "" {
			outDate, _ = parseDate(period.Out)
		} else {
			outDate = calcDate
		}

		if i == 0 && period.In == "" {
			inDate = oneYearAgo
			if outDate.Before(oneYearAgo) {
				continue
			}
		} else {
			inDate, _ = parseDate(period.In)
		}

		// –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ö—Ä–æ–Ω–æ–ª–æ–≥–∏–∏
		if i > 0 && inDate.Before(previousOutDate) {
			return fmt.Sprintf("–û—à–∏–±–∫–∞: –ø–µ—Ä–∏–æ–¥—ã –Ω–µ –≤ —Ö—Ä–æ–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–º –ø–æ—Ä—è–¥–∫–µ (–ø–µ—Ä–∏–æ–¥ %d)", i+1)
		}

		// –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑—Ä—ã–≤–∞ –º–µ–∂–¥—É –ø—Ä–µ–¥—ã–¥—É—â–∏–º –∏ —Ç–µ–∫—É—â–∏–º
		if i > 0 && !previousOutDate.IsZero() {
			gapStart := previousOutDate.AddDate(0, 0, 1)
			if gapStart.Before(inDate) {
				gapEnd := inDate.AddDate(0, 0, -1)
				// –æ–±—Ä–µ–∑–∞–µ–º –¥–æ –æ–∫–Ω–∞
				if gapEnd.After(calcDate) {
					gapEnd = calcDate
				}
				if gapStart.Before(oneYearAgo) {
					gapStart = oneYearAgo
				}
				if !gapStart.After(gapEnd) {
					days := int(gapEnd.Sub(gapStart).Hours()/24) + 1
					countryDays["unknown"] += days
				}
			}
		}

		previousOutDate = outDate

		// –æ–±—Ä–µ–∑–∫–∞ –¥–æ –æ–∫–Ω–∞
		if outDate.Before(oneYearAgo) {
			continue
		}
		if inDate.Before(oneYearAgo) {
			inDate = oneYearAgo
		}
		if outDate.After(calcDate) {
			outDate = calcDate
		}
		if inDate.After(outDate) {
			continue
		}

		effectiveOutDate := outDate.AddDate(0, 0, 1)
		days := int(effectiveOutDate.Sub(inDate).Hours() / 24)
		countryDays[period.Country] += days
	}

	if len(countryDays) == 0 {
		return "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥."
	}

	type stat struct {
		Country string
		Days    int
	}
	var stats []stat
	for c, d := range countryDays {
		stats = append(stats, stat{c, d})
	}
	sort.Slice(stats, func(i, j int) bool {
		return stats[i].Days > stats[j].Days
	})

	builder := strings.Builder{}
	builder.WriteString(fmt.Sprintf("–ê–Ω–∞–ª–∏–∑ –∑–∞ –ø–µ—Ä–∏–æ–¥: %s ‚Äî %s\n\n", formatDate(oneYearAgo), formatDate(calcDate)))
	for _, s := range stats {
		if s.Country == "unknown" {
			builder.WriteString(fmt.Sprintf("üï≥ –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ –≥–¥–µ: %d –¥–Ω–µ–π\n", s.Days))
			continue
		}
		iso := countryCodeMap[s.Country]
		flag := countryToFlag(iso)
		builder.WriteString(fmt.Sprintf("%s %s: %d –¥–Ω–µ–π\n", flag, s.Country, s.Days))
	}

	builder.WriteString("\n")
	if stats[0].Country != "unknown" && stats[0].Days >= 183 {
		iso := countryCodeMap[stats[0].Country]
		flag := countryToFlag(iso)
		builder.WriteString(fmt.Sprintf("‚úÖ –ù–∞–ª–æ–≥–æ–≤—ã–π —Ä–µ–∑–∏–¥–µ–Ω—Ç: %s %s (%d –¥–Ω–µ–π)\n", flag, stats[0].Country, stats[0].Days))
	} else {
		for _, s := range stats {
			if s.Country != "unknown" {
				builder.WriteString(fmt.Sprintf("‚ö†Ô∏è –ù–µ—Ç —Å—Ç—Ä–∞–Ω—ã —Å >=183 –¥–Ω—è–º–∏. –ë–æ–ª—å—à–µ –≤—Å–µ–≥–æ –≤: %s (%d –¥–Ω–µ–π)\n", s.Country, s.Days))
				break
			}
		}
	}

	return builder.String()
}

func formatPeriodList(periods []Period, current string) string {
	var builder strings.Builder
	builder.WriteString("üìã –°–ø–∏—Å–æ–∫ –ø–µ—Ä–∏–æ–¥–æ–≤:\n\n")
	for i, p := range periods {
		in := p.In
		if in == "" {
			in = "‚Äî"
		}
		out := p.Out
		if out == "" {
			out = "–ø–æ " + current
		}
		builder.WriteString(fmt.Sprintf("%d. %s ‚Äî %s (%s)\n", i+1, in, out, p.Country))
	}
	return builder.String()
}

func getSession(userID int64) *Session {
	s, ok := sessions[userID]
	if !ok {
		s = &Session{UserID: userID}
		s.HistoryDir = ensureDirs(userID)
		loadUserData(s)
		sessions[userID] = s
	}
	return s
}

func isEmpty(s *Session) bool {
	return len(s.Data.Periods) == 0
}

func buildBackToMenu() tgbotapi.InlineKeyboardMarkup {
	return tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", "start"),
		),
	)
}

func buildMainMenu(s *Session) tgbotapi.InlineKeyboardMarkup {
	var buttons [][]tgbotapi.InlineKeyboardButton

	if isEmpty(s) {
		buttons = [][]tgbotapi.InlineKeyboardButton{
			tgbotapi.NewInlineKeyboardRow(tgbotapi.NewInlineKeyboardButtonData("üìé –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª", "upload_file")),
			tgbotapi.NewInlineKeyboardRow(tgbotapi.NewInlineKeyboardButtonData("‚ÑπÔ∏è –ü–æ–º–æ—â—å", "help")),
		}
	} else {
		buttons = [][]tgbotapi.InlineKeyboardButton{
			tgbotapi.NewInlineKeyboardRow(tgbotapi.NewInlineKeyboardButtonData("üìã –ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ", "periods")),
			tgbotapi.NewInlineKeyboardRow(tgbotapi.NewInlineKeyboardButtonData("üìä –û—Ç—á—ë—Ç", "show_report")),
			tgbotapi.NewInlineKeyboardRow(tgbotapi.NewInlineKeyboardButtonData("üìÖ –û—Ç—á—ë—Ç –Ω–∞ –∑–∞–¥–∞–Ω–Ω—É—é –¥–∞—Ç—É", "set_date")),
			tgbotapi.NewInlineKeyboardRow(tgbotapi.NewInlineKeyboardButtonData("üìé –ó–∞–≥—Ä—É–∑–∏—Ç—å –Ω–æ–≤—ã–π —Ñ–∞–π–ª", "upload_report")),
			tgbotapi.NewInlineKeyboardRow(tgbotapi.NewInlineKeyboardButtonData("üóë –°–±—Ä–æ—Å–∏—Ç—å", "reset")),
			tgbotapi.NewInlineKeyboardRow(tgbotapi.NewInlineKeyboardButtonData("‚ÑπÔ∏è –ü–æ–º–æ—â—å", "help")),
		}
	}

	return tgbotapi.NewInlineKeyboardMarkup(buttons...)
}

func buildPeriodsList(s *Session) string {
	builder := strings.Builder{}
	builder.WriteString("üìã –°–ø–∏—Å–æ–∫ –ø–µ—Ä–∏–æ–¥–æ–≤:\n\n")
	for i, p := range s.Data.Periods {
		in := p.In
		if in == "" {
			in = "‚Äî"
		}
		out := p.Out
		if out == "" {
			out = "–ø–æ " + s.Data.Current
		}
		builder.WriteString(fmt.Sprintf("%d. %s ‚Äî %s (%s)\n", i+1, in, out, p.Country))
	}
	return builder.String()
}
